%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Template for creating scribe notes for MLPM2013.
%
%  Fill in your name, lecture number, lecture date and body
%  of scribe notes as indicated below.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[11pt]{article}

\newcommand\independent{\protect\mathpalette{\protect\independenT}{\perp}}
\def\independenT#1#2{\mathrel{\rlap{$#1#2$}\mkern2mu{#1#2}}}
\setlength{\topmargin}{0pt}
\setlength{\textheight}{9in}
\setlength{\headheight}{0pt}
\setlength{\headsep}{0pt}
\setlength{\oddsidemargin}{0.25in}
\setlength{\textwidth}{6in}
\pagestyle{plain}
\usepackage{tikz}
\usepackage{amssymb}
\usetikzlibrary{calc}
\usetikzlibrary{positioning}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{amsmath}
\begin{document}

\begin{center}
\textbf{Personalized Mario}

\end{center}



\section{Gradient Ascent Optimization}
The algorithm I implemented is a variation of the gradient ascent algorithm.  
What is being optimized is the difficulty settings of the game at each segment, by calculating the gradient of emotions at the present and previous segment. 

Before presenting the algorithm, there are some fundamentals to be discussed. 

\begin{itemize}


\item Emotions are tracked while the game is being played, but they are processed and taken into account at the event of a segment being finished or death of Mario (offline).
\item Emotions are calculated for each section separately, thus providing us with 5 vectors of emotions at each game segment. The calculations are done for each segment independently. 
\item Segments are considered independent of each other. Performance in segment $t$ does not affect the difficulty of segment $t+1$
\item Emotions affecting the calculations are: Neutral, Happy \& Angry.
\item The starting difficulty is "1" for each section.
\end{itemize}

The algorithm is provided step by step below: 


\begin{algorithm}
\caption{Gradient Ascent Optimization for Personalized Mario}\label{euclid}
\begin{algorithmic}[1]
\Procedure{GAOptimize}{$e_t,e_{t-1}$}\Comment{Emotion vectors of current and previous segment}

   \State $\alpha\gets 1-variance(e_1)$\Comment{compute alpha (first segment)}
   \State $\delta \gets \alpha*5$\Comment{scale to difficulty space [-5...5]}
      \For{$each : Section$}

      \State $\epsilon\gets argmax|e_t-e_{t-1}|$ \Comment{Get the highest emotion difference}
      \State $nextAction\gets\epsilon*\delta$\Comment{Calculate next action (raise/lower difficulty)}
      \If{$\epsilon\in\{angry,neutral\}$}\Comment{If the emotion change is "negative"}
      \State{$nextAction \gets -nextAction$}
      \EndIf
       \State{$nextDifficulty\gets previousDifficulty + nextAction$}\Comment{Calculate next difficulty}
      \State \textbf{return} $newDifficulty$
   \EndFor
   
\EndProcedure
\end{algorithmic}
\end{algorithm}

There are a few features that aim towards implementing the algorithm, that do not belong to the gradient ascent implementation but are mostly of heuristic nature.
\begin{itemize}
\item Post-death emotions can directly change the difficulty (before segment is finished)
\item High average of neutral emotion will result in a minimum increase in difficulty (The threshold should be relevant to $\alpha$)
\end{itemize}

\section{Evaluation Hypotheses}
This implementation will be tested in comparison with an existing baseline implementation of Infinite Mario, which is not using facial expression recognition. 

I expect this implementation to perform at least equally good with the baseline algorithm, although due to the high probability of neutral expressions while playing, some players may find it quite challenging, or even hard to play.

The way the algorithm is designed, I expect it to converge to an optimal level of difficulty, where the emotions of the user will be stable and not dominated by neutral. However, given the fact that the emotion recognition software is not perfect, and could produce false predictions, in some cases I expect user disappointment. This is the reason why I have added some heuristic features to the algorithm, to tackle problems like the one mentioned previously.


\section{Experimentation}

Since the $\alpha$ factor is computed automatically, this feature will not be tuned in the experimentation. 

One possible experiment could be a variety of starting difficulties, to test the convergence speed of the algorithm, or maybe also test its responsiveness to user dissatisfaction (when the game starts at really high levels of difficulty). 

The baseline experiment will ask the user to play a number of segments which will be produced by either the baseline implementation or the one I'm presenting. In fact, the user should not be told when his expressions are recorded in order for him to provide me with unbiased feedback. 

The results I'm looking to reach is user satisfaction, a feeling that the game is adapting to the user's requirements and minimum game abandonment.

\section{Evaluation}


\begin{itemize}
\item Maximize happiness: happiness curve should incline after N segments.
\item Decrease neutral as much as possible. We want the user to be as emotional as possible, to boost our decision making.
\item Evaluate the stability of neutral. If neutral percentages are high, this could also mean the user is satisfied. For example, if the initial angry levels are high and then start to decline.
\item Test on different kinds of persons, (not expressive / really expressive) and evaluate the speed of convergence to some particular difficulty levels.

\end{itemize}
\end{document}
